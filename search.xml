<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2021/10/28/huan-cun-ji-chuan-xue-beng-chuan-tou/"/>
      <url>/2021/10/28/huan-cun-ji-chuan-xue-beng-chuan-tou/</url>
      
        <content type="html"><![CDATA[<blockquote><p>你知道的越多，你不知道的越多</p></blockquote><blockquote><p>点赞再看，养成习惯</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> <strong>Redis</strong>在互联网技术存储方面使用如此广泛，几乎所有的后端技术面试官都要在<strong>Redis</strong>的使用和原理方面对小伙伴们进行360°的刁难。作为一个在互联网公司面一次拿一次offer的面霸（<strong>请允许我使用一下夸张的修辞手法</strong>），打败了无数竞争对手，每次都只能看到无数落寞的身影失望的离开，略感愧疚，在一个寂寞难耐的夜晚，我痛定思痛，决定开始写<strong>《吊打面试官》</strong>系列，希望能帮助各位读者以后面试势如破竹，对面试官进行360°的反击，吊打问你的面试官，让一同面试的同僚瞠目结舌，疯狂收割大厂offer！</p><h2 id="一点感慨"><a href="#一点感慨" class="headerlink" title="一点感慨"></a>一点感慨</h2><p> 本来都把稿子放到公众号保存了，洗澡的时候想了一下晚上的比赛，觉得还是打开电脑写点东西，跟文章内容没关系，只是一点个人的感慨，不知道多少小伙伴看了昨天<strong>SKT VS G2</strong>的比赛，又不知道多少小伙伴还记得<strong>Faker</strong>手抖的那一幕。</p><p> <img src="https://pic.rmb.bdstatic.com/0def24612fc43cb8cd7e83ff068644934595.gif"></p><p> 不知道你们看了是什么感受，我看到他手抖的时候我内心也抖了，世界赛我支持的都是<strong>LPL</strong>的队伍，但是我喜欢李哥这个人，那种对胜利的执著，这么多年了那种坚持自己的坚持，这么多利益诱惑在面前却只想要胜利，这样的人我好喜欢啊，我想很多人也喜欢。</p><p> <img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8m0agafxfj307v0e0glv.jpg"></p><p> 可能就像很多网友说的那样，英雄迟暮，但是我觉得他还是有点东西，就像很多人说我们程序员只能吃年轻饭一样，但是如果你坚持自己的坚持，做个腹有诗书气自华的仔，我想最后肯定会得到自己的得到。</p><p> 好了我也不煽情了，我们开始讲技术吧。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p> 上一期吊打系列我们提到了Redis的基础知识，还没看的小伙伴可以回顾一下 </p><p> <a href="https://juejin.im/post/5db66ed9e51d452a2f15d833">《吊打面试官》系列-Redis基础</a></p><p> 那提到<strong>Redis</strong>我相信各位在面试，或者实际开发过程中对缓存<strong>雪崩</strong>，<strong>穿透</strong>，<strong>击穿</strong>也不陌生吧，就算没遇到过但是你肯定听过，那三者到底有什么区别，我们又应该怎么去防止这样的情况发生呢，我们有请下一位受害者。</p><h2 id="面试开始"><a href="#面试开始" class="headerlink" title="面试开始"></a>面试开始</h2><blockquote><p>一个大腹便便，穿着格子衬衣的中年男子，拿着一个满是划痕的mac向你走来，看着快秃顶的头发，心想着肯定是尼玛顶级架构师吧！但是我们腹有诗书气自华，虚都不虚。</p></blockquote><p> <img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1572684195247&amp;di=028e6f6a8788bb3cee016bdb86254945&amp;imgtype=0&amp;src=http://gss0.baidu.com/9vo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh=800,450/sign=2708ae14db160924dc70aa13e43719ce/f11f3a292df5e0fe08d04043576034a85fdf72ac.jpg"></p><h3 id="小伙子我看你的简历上写到了Redis，那么我们直接开门见山，直接怼常见的几个大问题，Redis雪崩了解么？"><a href="#小伙子我看你的简历上写到了Redis，那么我们直接开门见山，直接怼常见的几个大问题，Redis雪崩了解么？" class="headerlink" title="小伙子我看你的简历上写到了Redis，那么我们直接开门见山，直接怼常见的几个大问题，Redis雪崩了解么？"></a>小伙子我看你的简历上写到了Redis，那么我们直接开门见山，直接怼常见的几个大问题，Redis雪崩了解么？</h3><p> 帅气迷人的面试官您好，我了解的，目前电商首页以及热点数据都会去做缓存 ，一般缓存都是定时任务去刷新，或者是查不到之后去更新的，定时任务刷新就有一个问题。</p><p> <strong>举个简单的例子</strong>：如果所有首页的Key失效时间都是12小时，中午12点刷新的，我零点有个秒杀活动大量用户涌入，假设当时每秒 6000 个请求，本来缓存在可以扛住每秒 5000 个请求，但是缓存当时所有的Key都失效了。此时 1 秒 6000 个请求全部落数据库，数据库必然扛不住，它会报一下警，真实情况可能DBA都没反应过来就直接挂了。此时，如果没用什么特别的方案来处理这个故障，DBA 很着急，重启数据库，但是数据库立马又被新的流量给打死了。这就是我理解的缓存雪崩。</p><p> <strong>我刻意看了下我做过的项目感觉再吊的都不允许这么大的QPS直接打DB去，不过没慢SQL加上分库，大表分表可能还还算能顶，但是跟用了Redis的差距还是很大</strong></p><p> <img src="https://user-gold-cdn.xitu.io/2019/11/3/16e30d2c5e17899c?w=574&amp;h=500&amp;f=png&amp;s=38474"></p><p> <strong>同一时间大面积失效，那一瞬间Redis跟没有一样，那这个数量级别的请求直接打到数据库几乎是灾难性的，你想想如果打挂的是一个用户服务的库，那其他依赖他的库所有的接口几乎都会报错，如果没做熔断等策略基本上就是瞬间挂一片的节奏，你怎么重启用户都会把你打挂，等你能重启的时候，用户早就睡觉去了，并且对你的产品失去了信心，什么垃圾产品。</strong></p><h3 id="面试官摸了摸自己的头发，嗯还不错，那这种情况咋整？你都是怎么去应对的？"><a href="#面试官摸了摸自己的头发，嗯还不错，那这种情况咋整？你都是怎么去应对的？" class="headerlink" title="面试官摸了摸自己的头发，嗯还不错，那这种情况咋整？你都是怎么去应对的？"></a>面试官摸了摸自己的头发，嗯还不错，那这种情况咋整？你都是怎么去应对的？</h3><p> 处理缓存雪崩简单，在批量往<strong>Redis</strong>存数据的时候，把每个Key的失效时间都加个随机值就好了，这样可以保证数据不会在同一时间大面积失效，我相信，Redis这点流量还是顶得住的。</p><pre class=" language-java"><code class="language-java">setRedis（Key，value，time <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">10000</span>）；</code></pre><p> 如果<strong>Redis</strong>是集群部署，将热点数据均匀分布在不同的<strong>Redis</strong>库中也能避免全部失效的问题，不过本渣我在生产环境中操作集群的时候，单个服务都是对应的单个<strong>Redis</strong>分片，是为了方便数据的管理，但是也同样有了可能会失效这样的弊端，失效时间随机是个好策略。</p><p> 或者设置热点数据永远不过期，有更新操作就更新缓存就好了（比如运维更新了首页商品，那你刷下缓存就完事了，不要设置过期时间），电商首页的数据也可以用这个操作，保险。</p><h3 id="那你了解缓存穿透和击穿么，可以说说他们跟雪崩的区别么？"><a href="#那你了解缓存穿透和击穿么，可以说说他们跟雪崩的区别么？" class="headerlink" title="那你了解缓存穿透和击穿么，可以说说他们跟雪崩的区别么？"></a>那你了解缓存穿透和击穿么，可以说说他们跟雪崩的区别么？</h3><p> 嗯，了解，我先说一下缓存穿透吧，缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，我们数据库的 id 都是1开始自增上去的，如发起为id值为 -1 的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大，严重会击垮数据库。</p><p> <strong>小点的单机系统，基本上用postman就能搞死，比如我自己买的阿里云服务</strong></p><p> <img src="https://user-gold-cdn.xitu.io/2019/11/3/16e30d1847df0faf?w=458&amp;h=480&amp;f=png&amp;s=30569"></p><p> <strong>像这种你如果不对参数做校验，数据库id都是大于0的，我一直用小于0的参数去请求你，每次都能绕开Redis直接打到数据库，数据库也查不到，每次都这样，并发高点就容易崩掉了。</strong></p><p> 至于<strong>缓存击穿</strong>嘛，这个跟<strong>缓存雪崩</strong>有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了DB，而缓存击穿不同的是<strong>缓存击穿</strong>是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞。</p><p> <img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1572683877606&amp;di=abb0c6a9d0acca45a729b7ab516c6e20&amp;imgtype=0&amp;src=http://img.juimg.com/tuku/yulantu/110214/6462-11021411045623.jpg"></p><h3 id="面试官露出欣慰的眼光，那他们分别怎么解决"><a href="#面试官露出欣慰的眼光，那他们分别怎么解决" class="headerlink" title="面试官露出欣慰的眼光，那他们分别怎么解决"></a>面试官露出欣慰的眼光，那他们分别怎么解决</h3><p> <strong>缓存穿透</strong>我会在接口层增加校验，比如用户鉴权校验，参数做校验，不合法的参数直接代码Return，比如：id 做基础校验，id &lt;=0的直接拦截等。</p><p> <strong>这里我想提的一点就是，我们在开发程序的时候都要有一颗“不信任”的心，就是不要相信任何调用方，比如你提供了API接口出去，你有这几个参数，那我觉得作为被调用方，任何可能的参数情况都应该被考虑到，做校验，因为你不相信调用你的人，你不知道他会传什么参数给你。</strong></p><p> <strong>举个简单的例子，你这个接口是分页查询的，但是你没对分页参数的大小做限制，调用的人万一一口气查 Integer.MAX_VALUE 一次请求就要你几秒，多几个并发你不就挂了么？是公司同事调用还好大不了发现了改掉，但是如果是黑客或者竞争对手呢？在你双十一当天就调你这个接口会发生什么，就不用我说了吧。这是之前的Leader跟我说的，我觉得大家也都应该了解下。</strong></p><p> 从缓存取不到的数据，在数据库中也没有取到，这时也可以将对应Key的Value对写为null、位置错误、稍后重试这样的值具体取啥问产品，或者看具体的场景，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。</p><p> 这样可以防止攻击用户反复用同一个id暴力攻击，但是我们要知道正常用户是不会在单秒内发起这么多次请求的，那网关层<strong>Nginx</strong>本渣我也记得有配置项，可以让运维大大对单个IP每秒访问次数超出阈值的IP都拉黑。</p><h3 id="那你还有别的办法么？"><a href="#那你还有别的办法么？" class="headerlink" title="那你还有别的办法么？"></a>那你还有别的办法么？</h3><p> 还有我记得<strong>Redis</strong>还有一个高级用法<strong>布隆过滤器（Bloom Filter）</strong>这个也能很好的防止缓存穿透的发生，他的原理也很简单就是利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查了DB刷新KV再return。</p><p> 那又有小伙伴说了如果黑客有很多个IP同时发起攻击呢？这点我一直也不是很想得通，但是一般级别的黑客没这么多肉鸡，再者正常级别的<strong>Redis</strong>集群都能抗住这种级别的访问的，小公司我想他们不会感兴趣的。把系统的高可用做好了，集群还是很能顶的。</p><p> <strong>缓存击穿</strong>的话，设置热点数据永远不过期。或者加上互斥锁就能搞定了</p><p> <strong>作为暖男，代码我肯定帮你们准备好了</strong></p><p> <img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8mg8yjuyqj30ug0u0guk.jpg"></p><p> ##面试结束</p><pre><code>### 嗯嗯还不错，三个点都回答得很好，今天也不早了，面试就先到这里，明天你再过来二面我继续问一下你关于Redis集群高可用，主从同步，哨兵等知识点的问题。晕居然还有下一轮面试！（强行下一期的伏笔哈哈）但是为了offer还是得舔，嗯嗯，好的帅气面试官。能回答得这么全面这么细节还是忍不住点赞（**暗示点赞，每次都看了不点赞，你们想白嫖我么？你们好坏喲，不过我喜欢**）## 总结我们玩归玩，闹归闹，别拿面试开玩笑。本文简单的介绍了，**Redis**的**雪崩**，**击穿**，**穿透**，三者其实都差不多，但是又有一些区别，在面试中其实这是问到缓存必问的，大家不要把三者搞混了，因为缓存雪崩、穿透和击穿，是缓存最大的问题，要么不出现，一旦出现就是致命性的问题，所以面试官一定会问你。大家一定要理解是**怎么发生的**，以及是怎么去**避免**的，发生之后又怎么去**抢救**，你可以不是知道很深入，但是你不能一点都不去想，面试有时候不一定是对知识面的拷问，或许是对你的态度的拷问，如果你思路清晰，然后**知其然还知其所以然**那就很赞，还知道怎么预防那来上班吧。### 最后暖男我继续给你们做个小的技术总结：一般避免以上情况发生我们从三个时间段去分析下：- 事前：**Redis** 高可用，主从+哨兵，**Redis cluster**，避免全盘崩溃。- 事中：本地 **ehcache** 缓存 + **Hystrix** 限流+降级，避免** MySQL** 被打死。</code></pre><ul><li>事后：<strong>Redis</strong> 持久化 <strong>RDB</strong>+<strong>AOF</strong>，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</li></ul><p> 上面的几点我会在吊打系列Redis篇全部讲一下这个月应该可以吧Redis更完，限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？<strong>走降级</strong>！可以返回一些默认的值，或者友情提示，或者空白的值。</p><p> <strong>好处：</strong></p><p> 数据库绝对不会死，限流组件确保了每秒只有多少个请求能通过。 只要数据库不死，就是说，对用户来说，3/5 的请求都是可以被处理的。 只要有 3/5 的请求可以被处理，就意味着你的系统没死，对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来一次。</p><p> <strong>这个在目前主流的互联网大厂里面是最常见的，你是不是好奇，某明星爆出什么事情，你发现你去微博怎么刷都空白界面，但是有的人又直接进了，你多刷几次也出来了，现在知道了吧，那是做了降级，牺牲部分用户的体验换来服务器的安全，可还行？</strong></p><p> 好了各位，以上就是这篇文章的全部内容了，能看到这里的人呀，都是<strong>人才</strong>，我后面会每周都更新几篇《<strong>吊打面试官</strong>》系列和Java技术栈相关的文章。如果你有什么想知道的，也可以留言给我，我一有时间就会写出来，我们共同进步。</p><p> 非常感谢<strong>靓仔/靓女</strong>您能看到这里，如果这个文章写得还不错的话 <strong>求点赞</strong> <strong>求关注</strong>  <strong>求分享</strong> <strong>求留言</strong> <strong>（对我非常有用）</strong>各位的支持和认可，就是我创作的最大动力，我们下篇文章见，拜了个拜！</p><p> 敖丙 | 文  【原创】</p><hr><blockquote><p>每周都会持续更新《吊打面试官》系列可以关注我的公众号第一时间阅读和催更，也可以在公众号回复【人才】加入人才交流群一起讨论面试题，就业和工作上有什么问题也可以直接滴滴我，我也是个新人，不过不影响我们一起进步，作为渣男，我给不了你工作，还给不了你温暖嘛？</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2019/11/1/16e25fd86ba8a0db?w=900&amp;h=500&amp;f=png&amp;s=185595"> </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/10/28/ke-dai-biao-zong-jie/"/>
      <url>/2021/10/28/ke-dai-biao-zong-jie/</url>
      
        <content type="html"><![CDATA[<blockquote><p>你知道的越多，你不知道的越多</p></blockquote><blockquote><p>点赞再看，养成习惯</p></blockquote><blockquote><p><strong>GitHub</strong>上已经开源 <a href="https://github.com/AobingJava/JavaFamily">https://github.com/JavaFamily</a> 有一线大厂面试点脑图、个人联系方式和人才交流群，欢迎Star和指教</p></blockquote><h2 id="絮叨"><a href="#絮叨" class="headerlink" title="絮叨"></a>絮叨</h2><p>本来是没这期的，按道理更新也应该是在周一更新<strong>消息队列</strong>的幂等，分布式事务相关的文章，但是这篇<strong>暖男</strong>我<strong>实在忍不住了</strong>，不是发自己的文章，是帮<strong>课代表</strong>发一下，她本科是<strong>北京交通大学</strong>，也是<strong>电子科技大学</strong>的研究生。</p><p><strong>她</strong>看了我的系列，做了个<strong>笔记</strong>📒，我一看，<strong>偶买噶 ！</strong>。</p><p><strong>这是什么仙女啊</strong>，这是我<strong>第一次</strong>有这种感觉，这笔记有着前<strong>所未有的新鲜感</strong>，细节的勾勒，让整个笔记更显出<strong>奥妙.</strong>…有些<strong>不太成熟的话语</strong>，跟我文章的<strong>骚气</strong>十分搭配，将<strong>Redis</strong>的性能衬托的更为出色，这才呈现出完美的<strong>课代表笔记</strong>。</p><p>这也是我第一次看到看个渣男的文章都做笔记的，这笔记让我有了初恋的味道，这我以后可得好好写了，不然<strong>辜负</strong>了<strong>课代表这样认真的妹子</strong>，到时候到杭州来找我：敖丙你个<strong>渣男</strong>乱写，害我没拿Offer！ <strong>我要杀了你</strong>！</p><p>我也不多BB了不影响大家食用了，<strong>课代表</strong>说了以后我写的<strong>其他技术栈的笔记</strong>一样会贡献出来，代价就是要嫁给我，呸呸呸，代价就是我以后帮他介绍大厂朋友内推下，看看简历呀，解答下职场问题啊什么的。（根本就是举手之劳啊，我血赚？）</p><p>我一听我不能忍啊，我<strong>气得拍桌子</strong>，不行你以后不懂的知识点我包了，我也不懂的咳咳我看完书再包？</p><p>哈哈开玩笑的，总之<strong>课代表的精神</strong>大家包括我都应该好好学学，这种人活该她拿<strong>SSP</strong>的Offer。</p><p><strong>Tip</strong>：SSP （Special Offer 优秀生源Offer渠道 ）</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g94ru45jrfj30u01hob29.jpg"></p><p>能总结得这么全面连我都忍不住<strong>点赞</strong>了！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>里面很多细节的点还是需要完善的，课代表最近上课很忙帅丙我呢除了周末也没时间，不过会不断完善到GIt的，大家也可以去公众号回复「<strong>课代表</strong>」获取思维导图原稿。</p><p>其实我真的很欣赏课代表这样的精神的，她这样的举动<strong>触动了我</strong>，想想自己大学时候的样子，我忍不住给了自己两嘴巴子，我但凡有课代表一半的努力都不至于沦落到今天这样，等我冷静下来，走到了窗边，眺望头上若影若现的月亮，<strong>我的眼角又湿了</strong>！</p><h2 id="花絮"><a href="#花絮" class="headerlink" title="花絮"></a>花絮</h2><p>人才群里的人才真的都是<strong>人才</strong>，一周两更<strong>高产似母猪</strong>了我都，还天天<strong>催更</strong>不过我也认了，<strong>课代表</strong>进去差点把人家吓走，<strong>这么好的课代表</strong>吓走了我哪里找第二个？</p><p><strong>GitHub</strong>上有我联系方式和入群方式 <a href="https://github.com/AobingJava/JavaFamily">https://github.com/JavaFamily</a></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g94qkzpjvnj30b40atjs9.jpg"></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g94qlkm935j30b40aojry.jpg"></p><h2 id="日常求赞"><a href="#日常求赞" class="headerlink" title="日常求赞"></a>日常求赞</h2><p>这期本来不想求赞的，但是我一想是<strong>课代表</strong>写的大家是给她赞，不是给我赞呀。</p><p>好了各位，以上就是这篇文章的全部内容了，能看到这里的人呀，都是<strong>人才</strong>。</p><p>我后面会每周都更新几篇《吊打面试官》系列和互联网常用技术栈相关的文章，非常感谢<strong>人才</strong>们能看到这里，如果这个文章写得还不错，觉得「课代表」<strong>有点东西</strong>的话   <strong>求点赞👍</strong> <strong>求关注❤️</strong>  <strong>求分享👥</strong>  对暖男我来说真的 <strong>非常有用</strong>！！！</p><p>创作不易，各位的支持和认可，就是我创作的最大动力，我们下篇文章见！</p><p>敖丙&amp;<strong>课代表</strong> | 文  【原创】【转载请联系本人】  如果本篇博客有任何错误，请批评指教，不胜感激 ！</p><hr><blockquote><p>《吊打面试官》系列每周持续更新，可以关注我的公众号「 <strong>JavaFamily</strong> 」第一时间阅读和催更（公众号比博客早一到两篇哟），本文<strong>GitHub</strong>上已经收录<a href="https://github.com/AobingJava/JavaFamily">https://github.com/JavaFamily</a>，有一线大厂面试点思维导图，欢迎Star和完善，里面也有我个人联系方式有什么问题也可以直接找我，也有人才交流群，我们一起有点东西。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g92gbyipnjj30p00dw79c.jpg"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/10/28/bu-long-guo-lu-qi-bloomfilter/"/>
      <url>/2021/10/28/bu-long-guo-lu-qi-bloomfilter/</url>
      
        <content type="html"><![CDATA[<p>避免缓存击穿的利器之BloomFilter</p><h1 id="Bloom-Filter-概念"><a href="#Bloom-Filter-概念" class="headerlink" title="Bloom Filter 概念"></a>Bloom Filter 概念</h1><p>布隆过滤器（英语：Bloom Filter）是1970年由一个叫布隆的小伙子提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</p><p><em><strong>面试关联：一般都会在回答缓存穿透，或者海量数据去重这个时候引出来，加分项哟</strong></em></p><h1 id="Bloom-Filter-原理"><a href="#Bloom-Filter-原理" class="headerlink" title="Bloom Filter 原理"></a>Bloom Filter 原理</h1><p> 布隆过滤器的原理是，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。</p><p>Bloom Filter跟单哈希函数Bit-Map不同之处在于：Bloom Filter使用了k个哈希函数，每个字符串跟k个bit对应。从而降低了冲突的概率。</p><p> <img src="https://images2018.cnblogs.com/blog/740591/201806/740591-20180623183045586-692673875.jpg" alt="img"></p><p>简单的说一下就是我们先把我们数据库的数据都加载到我们的过滤器中，比如数据库的id现在有：1、2、3</p><p>那就用id：1 为例子他在上图中经过三次hash之后，把三次原本值0的地方改为1</p><p>下次我进来查询如果id也是1 那我就把1拿去三次hash 发现跟上面的三个位置完全一样，那就能证明过滤器中有1的</p><p>反之如果不一样就说明不存在了</p><p>那应用的场景在哪里呢？一般我们都会用来防止缓存击穿（如果不知道缓存击穿是啥的小伙伴不要着急，我已经帮你准备好了，传送门 ↓ ）</p><p>简单来说就是你数据库的id都是1开始然后自增的，那我知道你接口是通过id查询的，我就拿负数去查询，这个时候，会发现缓存里面没这个数据，我又去数据库查也没有，一个请求这样，100个，1000个，10000个呢？你的DB基本上就扛不住了，如果在缓存里面加上这个，是不是就不存在了，你判断没这个数据就不去查了，直接return一个数据为空不就好了嘛。</p><p>这玩意这么好使那有啥缺点么？有的，我们接着往下看</p><h1 id="Bloom-Filter的缺点"><a href="#Bloom-Filter的缺点" class="headerlink" title="Bloom Filter的缺点"></a>Bloom Filter的缺点</h1><p>bloom filter之所以能做到在时间和空间上的效率比较高，是因为牺牲了判断的准确率、删除的便利性</p><ul><li><p>存在误判，可能要查到的元素并没有在容器中，但是hash之后得到的k个位置上值都是1。如果bloom filter中存储的是黑名单，那么可以通过建立一个白名单来存储可能会误判的元素。</p></li><li><p>删除困难。一个放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为0，可能会影响其他元素的判断。可以采用<a href="http://wiki.corp.qunar.com/confluence/download/attachments/199003276/US9740797.pdf?version=1&amp;modificationDate=1526538500000&amp;api=v2">Counting Bloom Filter</a></p></li></ul><h1 id="Bloom-Filter-实现"><a href="#Bloom-Filter-实现" class="headerlink" title="Bloom Filter 实现"></a>Bloom Filter 实现</h1><p>布隆过滤器有许多实现与优化，Guava中就提供了一种Bloom Filter的实现。</p><p> 在使用bloom filter时，绕不过的两点是预估数据量n以及期望的误判率fpp，</p><p> 在实现bloom filter时，绕不过的两点就是hash函数的选取以及bit数组的大小。</p><p> 对于一个确定的场景，我们预估要存的数据量为n，期望的误判率为fpp，然后需要计算我们需要的Bit数组的大小m，以及hash函数的个数k，并选择hash函数</p><h2 id="1-Bit数组大小选择"><a href="#1-Bit数组大小选择" class="headerlink" title="(1)Bit数组大小选择"></a>(1)Bit数组大小选择</h2><p>  　　根据预估数据量n以及误判率fpp，bit数组大小的m的计算方式：<img src="https://images2018.cnblogs.com/blog/740591/201806/740591-20180623183107851-1156064550.png" alt="img"></p><h2 id="2-哈希函数选择"><a href="#2-哈希函数选择" class="headerlink" title="(2)哈希函数选择"></a>(2)哈希函数选择</h2><p>​      由预估数据量n以及bit数组长度m，可以得到一个hash函数的个数k：<img src="https://images2018.cnblogs.com/blog/740591/201806/740591-20180623183135930-1940138772.png" alt="img"></p><p>​      哈希函数的选择对性能的影响应该是很大的，一个好的哈希函数要能近似等概率的将字符串映射到各个Bit。选择k个不同的哈希函数比较麻烦，一种简单的方法是选择一个哈希函数，然后送入k个不同的参数。</p><p> 哈希函数个数k、位数组大小m、加入的字符串数量n的关系可以参考<a href="http://pages.cs.wisc.edu/~cao/papers/summary-cache/node8.html">Bloom Filters - the math</a>，<a href="https://en.wikipedia.org/wiki/Bloom_filter">Bloom_filter-wikipedia</a></p><p>要使用BloomFilter，需要引入guava包：</p><pre class=" language-java"><code class="language-java"> <span class="token operator">&lt;</span>dependency<span class="token operator">></span>            <span class="token operator">&lt;</span>groupId<span class="token operator">></span>com<span class="token punctuation">.</span>google<span class="token punctuation">.</span>guava<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>guava<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>            <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">23.0</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span> <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>    </code></pre><p>测试分两步：</p><p>1、往过滤器中放一百万个数，然后去验证这一百万个数是否能通过过滤器</p><p>2、另外找一万个数，去检验漏网之鱼的数量</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 测试布隆过滤器(可用于redis缓存穿透) *  * @author 敖丙 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestBloomFilter</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> total <span class="token operator">=</span> <span class="token number">1000000</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> BloomFilter<span class="token operator">&lt;</span>Integer<span class="token operator">></span> bf <span class="token operator">=</span> BloomFilter<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Funnels<span class="token punctuation">.</span><span class="token function">integerFunnel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> total<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//    private static BloomFilter&lt;Integer> bf = BloomFilter.create(Funnels.integerFunnel(), total, 0.001);</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 初始化1000000条数据到过滤器中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> total<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            bf<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 匹配已在过滤器中的值，是否有匹配不上的</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> total<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bf<span class="token punctuation">.</span><span class="token function">mightContain</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"有坏人逃脱了~~~"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 匹配不在过滤器中的10000个值，有多少匹配出来</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> total<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> total <span class="token operator">+</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bf<span class="token punctuation">.</span><span class="token function">mightContain</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"误伤的数量："</span> <span class="token operator">+</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>运行结果：</p><p><img src="https://images2018.cnblogs.com/blog/647585/201809/647585-20180910085137286-1365750639.png" alt="img"></p><p>运行结果表示，遍历这一百万个在过滤器中的数时，都被识别出来了。一万个不在过滤器中的数，误伤了320个，错误率是0.03左右。</p><p>看下BloomFilter的源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> BloomFilter<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">create</span><span class="token punctuation">(</span>Funnel<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> funnel<span class="token punctuation">,</span> <span class="token keyword">int</span> expectedInsertions<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">create</span><span class="token punctuation">(</span>funnel<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> expectedInsertions<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> BloomFilter<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">create</span><span class="token punctuation">(</span>Funnel<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> funnel<span class="token punctuation">,</span> <span class="token keyword">long</span> expectedInsertions<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">create</span><span class="token punctuation">(</span>funnel<span class="token punctuation">,</span> expectedInsertions<span class="token punctuation">,</span> <span class="token number">0.03</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// FYI, for 3%, we always get 5 hash functions</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> BloomFilter<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">create</span><span class="token punctuation">(</span>          Funnel<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> funnel<span class="token punctuation">,</span> <span class="token keyword">long</span> expectedInsertions<span class="token punctuation">,</span> <span class="token keyword">double</span> fpp<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">create</span><span class="token punctuation">(</span>funnel<span class="token punctuation">,</span> expectedInsertions<span class="token punctuation">,</span> fpp<span class="token punctuation">,</span> BloomFilterStrategies<span class="token punctuation">.</span>MURMUR128_MITZ_64<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> BloomFilter<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">create</span><span class="token punctuation">(</span>      Funnel<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token operator">></span> funnel<span class="token punctuation">,</span> <span class="token keyword">long</span> expectedInsertions<span class="token punctuation">,</span> <span class="token keyword">double</span> fpp<span class="token punctuation">,</span> Strategy strategy<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span></code></pre><p>BloomFilter一共四个create方法，不过最终都是走向第四个。看一下每个参数的含义：</p><p>  funnel：数据类型(一般是调用Funnels工具类中的)</p><p>  expectedInsertions：期望插入的值的个数</p><p>  fpp 错误率(默认值为0.03)</p><p>  strategy 哈希算法(我也不懂啥意思)Bloom Filter的应用</p><p>在最后一个create方法中，设置一个断点：</p><p><img src="https://images2018.cnblogs.com/blog/647585/201809/647585-20180910132928928-1515000664.png" alt="img"></p><p><img src="https://images2018.cnblogs.com/blog/647585/201809/647585-20180910132846403-1134753024.png" alt="img"></p><p>上面的numBits，表示存一百万个int类型数字，需要的位数为7298440，700多万位。理论上存一百万个数，一个int是4字节32位，需要4<em>8</em>1000000=3200万位。如果使用HashMap去存，按HashMap50%的存储效率，需要6400万位。可以看出BloomFilter的存储空间很小，只有HashMap的1/10左右</p><p>上面的numHashFunctions，表示需要5个函数去存这些数字</p><p>使用第三个create方法，我们设置下错误率：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> BloomFilter<span class="token operator">&lt;</span>Integer<span class="token operator">></span> bf <span class="token operator">=</span> BloomFilter<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Funnels<span class="token punctuation">.</span><span class="token function">integerFunnel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> total<span class="token punctuation">,</span> <span class="token number">0.0003</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>再运行看看：</p><p><img src="https://images2018.cnblogs.com/blog/647585/201809/647585-20180910173353668-949099512.png" alt="img"></p><p>此时误伤的数量为4，错误率为0.04%左右。</p><p><img src="https://images2018.cnblogs.com/blog/647585/201809/647585-20180910172828950-221799643.png" alt="img"></p><p>当错误率设为0.0003时，所需要的位数为16883499，1600万位，需要12个函数</p><p>和上面对比可以看出，错误率越大，所需空间和时间越小，错误率越小，所需空间和时间约大 </p><p>常见的几个应用场景：</p><ul><li><p>cerberus在收集监控数据的时候, 有的系统的监控项量会很大, 需要检查一个监控项的名字是否已经被记录到db过了, 如果没有的话就需要写入db.</p></li><li><p>爬虫过滤已抓到的url就不再抓，可用bloom filter过滤</p></li><li><p>垃圾邮件过滤。如果用哈希表，每存储一亿个 email地址，就需要 1.6GB的内存（用哈希表实现的具体办法是将每一个 email地址对应成一个八字节的信息指纹，然后将这些信息指纹存入哈希表，由于哈希表的存储效率一般只有 50%，因此一个 email地址需要占用十六个字节。一亿个地址大约要 1.6GB，即十六亿字节的内存）。因此存贮几十亿个邮件地址可能需要上百 GB的内存。而Bloom Filter只需要哈希表 1/8到 1/4 的大小就能解决同样的问题。</p></li></ul><p><strong>觉得有用的话欢迎 关注 点赞 分享 【敖丙】| 文</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2021/10/28/redis-ji-chu/"/>
      <url>/2021/10/28/redis-ji-chu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>你知道的越多，你不知道的越多</p></blockquote><blockquote><p>点赞再看，养成习惯</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> <strong>Redis</strong>在互联网技术存储方面使用如此广泛，几乎所有的后端技术面试官都要在<strong>Redis</strong>的使用和原理方面对小伙伴们进行360°的刁难。作为一个在互联网公司面一次拿一次offer的面霸（<strong>请允许我使用一下夸张的修辞手法</strong>），打败了无数竞争对手，每次都只能看到无数落寞的身影失望的离开，略感愧疚，在一个寂寞难耐的夜晚，我痛定思痛，决定开始写《吊打面试官》系列，希望能帮助各位读者以后面试势如破竹，对面试官进行360°的反击，吊打问你的面试官，让一同面试的同僚铩羽而归，疯狂收割大厂offer！</p><h3 id="面试开始"><a href="#面试开始" class="headerlink" title="面试开始"></a>面试开始</h3><blockquote><p>一个大腹便便，穿着格子衬衣的中年男子，拿着一个满是划痕的mac向你走来，看着快秃顶的头发，心想着肯定是尼玛顶级架构师吧！但是我们腹有诗书气自华，虚都不虚。</p></blockquote><p> <img src="https://user-gold-cdn.xitu.io/2019/10/31/16e1ff35c9dc4843?w=500&amp;h=320&amp;f=png&amp;s=236215"></p><h3 id="小伙子您好，看你简历上写了你项目里面用到了Redis，你们为啥用Redis？"><a href="#小伙子您好，看你简历上写了你项目里面用到了Redis，你们为啥用Redis？" class="headerlink" title="小伙子您好，看你简历上写了你项目里面用到了Redis，你们为啥用Redis？"></a>小伙子您好，看你简历上写了你项目里面用到了Redis，你们为啥用Redis？</h3><p> 心里忍不住暗骂，这叫啥问题，大家不都是用的这个嘛，但是你不能说出来。</p><p> 认真回答道：<strong>帅气迷人的面试官您好</strong>，因为传统的关系型数据库如Mysql已经不能适用所有的场景了，比如秒杀的库存扣减，APP首页的访问流量高峰等等，都很容易把数据库打崩，所以引入了缓存中间件，目前市面上比较常用的缓存中间件有Redis 和 Memcached 不过中和考虑了他们的优缺点，最后选择了Redis。</p><p> <strong>至于更细节的对比朋友们记得查阅Redis 和 Memcached 的区别，比如两者的优缺点对比和各自的场景，后续我有时间也会写出来。</strong></p><h3 id="那小伙子，我再问你，Redis有哪些数据结构呀？"><a href="#那小伙子，我再问你，Redis有哪些数据结构呀？" class="headerlink" title="那小伙子，我再问你，Redis有哪些数据结构呀？"></a>那小伙子，我再问你，Redis有哪些数据结构呀？</h3><p> 字符串String、字典Hash、列表List、集合Set、有序集合SortedSet。</p><p> <strong>这里我相信99%的读者都能回答上来Redis的5个基本数据类型。如果回答不出来的小伙伴我们就要加油补课哟，大家知道五种类型最适合的场景更好。</strong></p><p> 但是，如果你是Redis中高级用户，而且你要在这次面试中突出你和其他候选人的不同，还需要加上下面几种数据结构HyperLogLog、Geo、Pub/Sub。</p><p> 如果你还想加分，那你说还玩过Redis Module，像BloomFilter，RedisSearch，Redis-ML，这个时候面试官得眼睛就开始发亮了，心想这个小伙子<strong>有点东西啊</strong>。</p><p> <strong><strong><strong>注：本人在面试回答到Redis相关的问题的时候，经常提到BloomFilter（布隆过滤器）这玩意的使用场景是真的多，而且用起来是真的香，原理也好理解，看一下文章就可以在面试官面前侃侃而谈了，不香么？下方传送门 ↓</strong></strong></strong></p><p> <a href="https://juejin.im/post/5db69365518825645656c0de">避免缓存穿透的利器之BloomFilter</a></p><h3 id="如果有大量的key需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的key需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的key需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的key需要设置同一时间过期，一般需要注意什么？</h3><p> 如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。严重的话会出现缓存雪崩，我们一般需要在时间上加一个随机值，使得过期时间分散一些。</p><p> <strong>电商首页经常会使用定时任务刷新缓存，可能大量的数据失效时间都十分集中，如果失效时间一样，又刚好在失效的时间点大量用户涌入，就有可能造成缓存雪崩</strong></p><h3 id="那你使用过Redis分布式锁么，它是什么回事？"><a href="#那你使用过Redis分布式锁么，它是什么回事？" class="headerlink" title="那你使用过Redis分布式锁么，它是什么回事？"></a>那你使用过Redis分布式锁么，它是什么回事？</h3><p> 先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。</p><h3 id="这时候对方会告诉你说你回答得不错，然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？"><a href="#这时候对方会告诉你说你回答得不错，然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？" class="headerlink" title="这时候对方会告诉你说你回答得不错，然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？"></a>这时候对方会告诉你说你回答得不错，然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？</h3><p> 这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要<strong>抓一抓自己得脑袋，故作思考片刻</strong>，好像接下来的结果是你主动思考出来的，然后回答：我记得set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！</p><h3 id="对方这时会显露笑容，心里开始默念：嗯，这小子还不错，开始有点意思了。"><a href="#对方这时会显露笑容，心里开始默念：嗯，这小子还不错，开始有点意思了。" class="headerlink" title="对方这时会显露笑容，心里开始默念：嗯，这小子还不错，开始有点意思了。"></a>对方这时会显露笑容，心里开始默念：嗯，这小子还不错，开始有点意思了。</h3><h3 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？</h3><p> 使用<strong>keys</strong>指令可以扫出指定模式的key列表。</p><h3 id="对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？"><a href="#对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？" class="headerlink" title="对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？"></a>对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？</h3><p> 这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用<strong>scan</strong>指令，<strong>scan</strong>指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p><p> <strong>不过，增量式迭代命令也不是没有缺点的： 举个例子， 使用 SMEMBERS 命令可以返回集合键当前包含的所有元素， 但是对于 SCAN 这类增量式迭代命令来说， 因为在对键进行增量式迭代的过程中， 键可能会被修改， 所以增量式迭代命令只能对被返回的元素提供有限的保证 。</strong></p><h3 id="使用过Redis做异步队列么，你是怎么用的？"><a href="#使用过Redis做异步队列么，你是怎么用的？" class="headerlink" title="使用过Redis做异步队列么，你是怎么用的？"></a>使用过Redis做异步队列么，你是怎么用的？</h3><p> 一般使用list结构作为队列，<strong>rpush</strong>生产消息，<strong>lpop</strong>消费消息。当lpop没有消息的时候，要适当sleep一会再重试。</p><h3 id="如果对方追问可不可以不用sleep呢？"><a href="#如果对方追问可不可以不用sleep呢？" class="headerlink" title="如果对方追问可不可以不用sleep呢？"></a>如果对方追问可不可以不用sleep呢？</h3><p> list还有个指令叫<strong>blpop</strong>，在没有消息的时候，它会阻塞住直到消息到来。</p><h3 id="如果对方接着追问能不能生产一次消费多次呢？"><a href="#如果对方接着追问能不能生产一次消费多次呢？" class="headerlink" title="如果对方接着追问能不能生产一次消费多次呢？"></a>如果对方接着追问能不能生产一次消费多次呢？</h3><p> 使用pub/sub主题订阅者模式，可以实现 1:N 的消息队列。</p><h3 id="如果对方继续追问-pub-su-b有什么缺点？"><a href="#如果对方继续追问-pub-su-b有什么缺点？" class="headerlink" title="如果对方继续追问 pub/su b有什么缺点？"></a>如果对方继续追问 pub/su b有什么缺点？</h3><p> 在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如<strong>RocketMQ</strong>等。</p><h3 id="如果对方究极TM追问Redis如何实现延时队列？"><a href="#如果对方究极TM追问Redis如何实现延时队列？" class="headerlink" title="如果对方究极TM追问Redis如何实现延时队列？"></a>如果对方究极TM追问Redis如何实现延时队列？</h3><p> 这一套连招下来，我估计现在你很想把面试官一棒打死（<strong>面试官自己都想打死自己了怎么问了这么多自己都不知道的</strong>），如果你手上有一根棒球棍的话，但是你很克制。平复一下激动的内心，然后神态自若的回答道：使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用<strong>zrangebyscore</strong>指令获取N秒之前的数据轮询进行处理。</p><p> <strong>到这里，面试官暗地里已经对你竖起了大拇指。并且已经默默给了你A+，但是他不知道的是此刻你却竖起了中指，在椅子背后。</strong></p><h3 id="Redis是怎么持久化的？服务主从数据怎么交互的？"><a href="#Redis是怎么持久化的？服务主从数据怎么交互的？" class="headerlink" title="Redis是怎么持久化的？服务主从数据怎么交互的？"></a>Redis是怎么持久化的？服务主从数据怎么交互的？</h3><p> RDB做镜像全量持久化，AOF做增量持久化。因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。</p><p> <strong>这里很好理解，把RDB理解为一整个表全量的数据，AOF理解为每次操作的日志就好了，服务器重启的时候先把表的数据全部搞进去，但是他可能不完整，你再回放一下日志，数据不就完整了嘛。不过Redis本身的机制是 AOF持久化开启且存在AOF文件时，优先加载AOF文件；AOF关闭或者AOF文件不存在时，加载RDB文件；加载AOF/RDB文件城后，Redis启动成功； AOF/RDB文件存在错误时，Redis启动失败并打印错误信息</strong></p><h3 id="对方追问那如果突然机器掉电会怎样？"><a href="#对方追问那如果突然机器掉电会怎样？" class="headerlink" title="对方追问那如果突然机器掉电会怎样？"></a>对方追问那如果突然机器掉电会怎样？</h3><p> 取决于AOF日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。</p><h3 id="对方追问RDB的原理是什么？"><a href="#对方追问RDB的原理是什么？" class="headerlink" title="对方追问RDB的原理是什么？"></a>对方追问RDB的原理是什么？</h3><p> 你给出两个词汇就可以了，fork和cow。fork是指redis通过创建子进程来进行RDB操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p><p> ******注：回答这个问题的时候，如果你还能说出AOF和RDB的优缺点，我觉得我是面试官在这个问题上我会给你点赞，两者其实区别还是很大的，而且涉及到Redis集群的数据同步问题等等。想了解的伙伴也可以留言，我会专门写一篇来介绍的。 ******</p><h3 id="Pipeline有什么好处，为什么要用pipeline？"><a href="#Pipeline有什么好处，为什么要用pipeline？" class="headerlink" title="Pipeline有什么好处，为什么要用pipeline？"></a>Pipeline有什么好处，为什么要用pipeline？</h3><p> 可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。</p><h3 id="Redis的同步机制了解么？"><a href="#Redis的同步机制了解么？" class="headerlink" title="Redis的同步机制了解么？"></a>Redis的同步机制了解么？</h3><p> Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可，有点类似数据库的binlog。</p><h3 id="是否使用过Redis集群，集群的高可用怎么保证，集群的原理是什么？"><a href="#是否使用过Redis集群，集群的高可用怎么保证，集群的原理是什么？" class="headerlink" title="是否使用过Redis集群，集群的高可用怎么保证，集群的原理是什么？"></a>是否使用过Redis集群，集群的高可用怎么保证，集群的原理是什么？</h3><p> Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。</p><p> Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</p><h2 id="面试结束"><a href="#面试结束" class="headerlink" title="面试结束"></a>面试结束</h2><h3 id="小伙子你可以的，什么时候有时间来上班啊，要不明天就来吧？"><a href="#小伙子你可以的，什么时候有时间来上班啊，要不明天就来吧？" class="headerlink" title="小伙子你可以的，什么时候有时间来上班啊，要不明天就来吧？"></a>小伙子你可以的，什么时候有时间来上班啊，要不明天就来吧？</h3><p> 你强装镇定，这么急啊我还需要租房，要不下礼拜一吧。</p><h3 id="好的-心想这小子这么NB是不是很多Offer在手上，不行我得叫hr给他加钱。"><a href="#好的-心想这小子这么NB是不是很多Offer在手上，不行我得叫hr给他加钱。" class="headerlink" title="好的 心想这小子这么NB是不是很多Offer在手上，不行我得叫hr给他加钱。"></a>好的 心想这小子这么NB是不是很多Offer在手上，不行我得叫hr给他加钱。</h3><p> 能撑到最后，你自己都忍不住自己给自己点个赞了!</p><p> （<strong>暗示点赞，每次都看了不点赞，你们想白嫖我么？你们好坏喲，不过我喜欢</strong>）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> <strong>在技术面试的时候，不管是Redis还是什么问题，如果你能举出实际的例子，或者是直接说自己开发过程的问题和收获会给面试官的印象分会加很多，回答逻辑性也要强一点，不要东一点西一点，容易把自己都绕晕的。</strong></p><p> <strong>还有一点就是我问你为啥用Redis你不要一上来就直接回答问题了，你可以这样回答：</strong></p><p> <strong>帅气的面试官您好</strong>，首先我们的项目DB遇到了瓶颈，特别是秒杀和热点数据这样的场景DB基本上就扛不住了，那就需要缓存中间件的加入了，目前市面上有的缓存中间件有 Redis 和 Memcached ，他们的优缺点……，综合这些然后再结合我们项目特点，最后我们在技术选型的时候选了谁。</p><p> 如果你这样有条不紊，有理有据的回答了我的问题而且还说出这么多我问题外的知识点，我会觉得你不只是一个会写代码的人，你逻辑清晰，你对技术选型，对中间件对项目都有自己的理解和思考，说白了就是你的offer有戏了。</p><p> 好了 以上就是这篇文章的全部内容了，我后面会不断更新《吊打面试官》系列和Java技术栈相关的文章。如果你有什么想知道的，也可以<strong>留言</strong>给我，我一有时间就会写出来，我们共同进步。</p><p> 非常感谢您能看到这里，如果这个文章写得还不错的话 <strong>求点赞</strong> <strong>求关注</strong>  <strong>求分享</strong> <strong>求留言</strong> 各位的支持和认可，就是我创作的最大动力，OK各位我们下期见！</p><p> 敖丙 | 文  </p><hr><blockquote><p>后面会持续更新《吊打面试官》系列可以关注我的公众号第一时间阅读，也会有朋友一线大厂的内推机会不定期推出（字节跳动，阿里，网易，PDD，滴滴，蘑菇街等），就业上有什么问题也可以直接微信滴滴我，我也是个新人，不过不影响我们一起进步，作为渣男，我给不了你工作，还给不了你温暖嘛？</p></blockquote><p> <img src="https://user-gold-cdn.xitu.io/2019/11/1/16e25fd86ba8a0db?w=900&amp;h=500&amp;f=png&amp;s=185595"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/10/28/hello-world/"/>
      <url>/2021/10/28/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
